## 一、箭头函数和普通函数的区别
   1. 箭头函数没有prototype，也没有arguments对象的
   2. 不能new(不可以当成构造函数使用)
   3. 箭头函数的this只在箭头函数定义时就决定，且不能被修改（call bind apply）
## 二、vue 修饰符
   1. input v-modal lazy  trim number   表单修饰符
   2. 事件修饰符  stop prevent self once native
   3. 鼠标修饰符 键盘修饰符--onkeyup onkeydown keyCode enter tab space esc

## 三、set和map   
## 四、观察者模式和发布订阅模式区别
观察者模式（Observer Pattern）和发布订阅模式（Publish-Subscribe Pattern）都是常见的软件设计模式，用于实现对象之间的解耦和消息通信。尽管它们有一些相似之处，但在实现和使用上存在一些区别。

观察者模式是一种一对多的依赖关系，其中一个对象（称为主题或可观察者）维护一个对象列表，称为观察者。当主题的状态发生变化时，它会自动通知所有注册的观察者，使其能够更新自己。观察者模式通过松散耦合的方式实现了对象之间的通信，使得主题和观察者可以独立变化，而不会相互紧密耦合。

发布订阅模式是一种更加灵活的消息通信模式，它允许一个发布者（也称为主题）向一个或多个订阅者发送消息，而订阅者可以选择订阅感兴趣的消息类型。发布者和订阅者之间通过消息代理（或称为事件总线）进行通信，发布者将消息发送到代理，而代理负责将消息传递给所有订阅者。与观察者模式不同，发布者和订阅者之间没有直接的依赖关系，它们只通过消息代理进行通信。

总结一下它们之间的区别：
- 观察者模式实现了一对多的依赖关系，主题维护一个观察者列表，并在状态变化时通知观察者更新。发布订阅模式允许发布者向多个订阅者发送消息，订阅者可以选择订阅感兴趣的消息类型。
- 在观察者模式中，主题和观察者之间存在直接的依赖关系，主题需要了解观察者的接口。而在发布订阅模式中，发布者和订阅者之间没有直接的依赖关系，它们只通过消息代理进行通信。
- 观察者模式更加简单直接，适用于一对多的通知场景。发布订阅模式更加灵活，适用于多对多的消息通信场景。

在实际应用中，你可以根据具体的需求和场景选择使用观察者模式或发布订阅模式。它们都可以提供一种有效的解耦和消息通信的方式，使得系统更加灵活和可扩展。

## 五、栈和队列区别，存哪的
## 六、广度优先遍历
   广度优先遍历（Breadth-First Search，简称 BFS）是一种遍历或搜索图形或树的算法，它从起始节点开始逐层遍历，先访问离起始节点最近的节点，然后逐渐扩展到离起始节点更远的节点。

   以下是广度优先遍历的基本步骤：

   1. 创建一个队列（一般使用先进先出的队列）和一个集合（用于存储已访问的节点）。
   2. 将起始节点放入队列中，并将其标记为已访问。
   3. 当队列不为空时，执行以下步骤：
      - 从队列中取出一个节点，记为当前节点。
      - 访问当前节点。
      - 将当前节点的所有未访问过的邻居节点放入队列中，并将它们标记为已访问。
   4. 重复步骤 3，直到队列为空。

   这样，广度优先遍历会按照节点的层级逐层遍历图形或树的节点。在执行过程中，保证了离起始节点更近的节点先被访问。

   下面是一个使用 JavaScript 实现广度优先遍历的示例代码，以遍历一个简单的图形结构：

   ```javascript
   // 定义一个图形结构的邻接表表示法
   const graph = {
   A: ['B', 'C'],
   B: ['A', 'D'],
   C: ['A', 'E'],
   D: ['B'],
   E: ['C']
   };

   function breadthFirstSearch(graph, startNode) {
   const visited = new Set();      // 用于存储已访问的节点
   const queue = [startNode];      // 创建一个队列，并将起始节点放入队列中

   while (queue.length > 0) {
      const currentNode = queue.shift();      // 从队列中取出一个节点
      console.log(currentNode);               // 访问当前节点

      visited.add(currentNode);                // 标记当前节点为已访问

      const neighbors = graph[currentNode];    // 获取当前节点的邻居节点数组

      for (const neighbor of neighbors) {
         if (!visited.has(neighbor)) {          // 如果邻居节点未被访问过
         queue.push(neighbor);                // 将邻居节点放入队列中
         visited.add(neighbor);               // 标记邻居节点为已访问
         }
      }
   }
   }

   // 调用广度优先遍历函数，以节点 A 为起始节点
   breadthFirstSearch(graph, 'A');
   ```

   在上述示例中，我们使用邻接表表示法定义了一个图形结构。然后，我们调用 `breadthFirstSearch` 函数，并将图形和起始节点作为参数传递进去。函数会按照广度优先的方式遍历图形，并输出每个访问的节点。

   请注意，上述示例中的图形是一个简单的无向图，您可以根据实际情况和需要进行相应的调整和修改。


## 它和树的前序中序后续遍历区别
   广度优先遍历（BFS）和树的前序、中序、后序遍历是不同的遍历算法，它们的区别如下：

   1. 遍历对象：
      - 广度优先遍历（BFS）：主要用于图形结构，也可以用于树结构。
      - 树的前序、中序、后序遍历：主要用于树结构。

   2. 遍历顺序：
      - 广度优先遍历（BFS）：按层级逐层遍历，先访问离起始节点最近的节点。
      - 树的前序遍历：先访问根节点，然后按照左子树、右子树的顺序遍历子树。
      - 树的中序遍历：按照左子树、根节点、右子树的顺序遍历子树。
      - 树的后序遍历：按照左子树、右子树、根节点的顺序遍历子树。

   3. 遍历方式：
      - 广度优先遍历（BFS）：使用队列进行遍历，通过不断入队和出队的方式实现。
      - 树的前序、中序、后序遍历：通常使用递归或栈来实现。

   4. 适用场景：
      - 广度优先遍历（BFS）：适用于寻找最短路径、图的连通性等问题。
      - 树的前序、中序、后序遍历：适用于树结构的遍历和搜索，例如构建表达式树、寻找二叉搜索树中的某个节点等。

   需要注意的是，树的前序、中序、后序遍历是针对二叉树而言，而广度优先遍历可以应用于一般的图形结构。

   总结起来，广度优先遍历（BFS）和树的前序、中序、后序遍历是不同的遍历算法，用于不同的数据结构和问题。广度优先遍历主要用于图形结构，按层级逐层遍历；而树的前序、中序、后序遍历主要用于树结构，按照不同的顺序遍历子树。