## 1 v-if和v-for为啥不能同时使用？ 优先级？
 1. v-if 和 v-for 都是 Vue.js 中的数据绑定指令，它们不能同时使用的原因是它们都会修改 DOM 结构。当 v-if 和 v-for 同时使用时，v-for 指令会优先执行，因为它会遍历循环中的所有元素，并将它们添加到 DOM 中。然后，v-if 指令会检查这些元素是否应该保留在 DOM 中。如果 v-if 指令移除了某个元素，那么 v-for 指令就会跳过这个元素，从而导致逻辑错误。

2. 优先级：v-for 指令的优先级高于 v-if 指令。在某些情况下，这可能会导致逻辑错误。例如，如果需要在列表中显示一个特定用户的信息，并且根据用户是否已登录来显示或隐藏用户信息，可以使用 v-if 和 v-for 指令。但是，由于 v-for 指令的优先级高于 v-if 指令，当登录用户的信息被移除时，可能会导致用户看到意外的内容。因此，在实际应用中，建议避免将 v-if 和 v-for 同时使用，以避免潜在的逻辑错误。
&& 注意：上述论证适用于vue2   在vue3中 v-if 比 v-for 的优先级更高。这意味着 v-if 的条件将无法访问到 v-for 作用域内定义的变量别名： 
总的来说 一般需要先将v-for的循环体用标签包裹（如`template`），然后用v-if来判断是否显示，这样可以避免上述问题。




## 2 flex属性三个参数的意义
 在HTML和CSS中，`flex`属性是一个属性值，它用于定义一个或多个项目在多行布局中的行为。`flex`属性有三个参数，分别是`flex-grow`、`flex-shrink`和`flex-basis`。下面是这三个参数的含义：

1. `flex-grow`：这个参数定义了项目在多行布局中扩展或缩小的方式。当所有项目都设置为`flex-grow`时，如果容器有剩余的空间，项目会平均地分配这个空间。如果某些项目有`flex-grow`，而其他项目没有，那么没有`flex-grow`的项目将不会分配空间，而是保持原始大小。值可以是数字（表示比例）或者`0`（表示不扩展，保持原始大小）。

2. `flex-shrink`：这个参数定义了项目在多行布局中缩放的方式。当所有项目都设置为`flex-shrink`时，如果容器需要减少空间，项目将平均地缩小。如果某些项目有`flex-shrink`，而其他项目没有，那么没有`flex-shrink`的项目将不会缩小，而是保持原始大小。值可以是数字（表示比例）或者`0`（表示不缩小，保持原始大小）。

3. `flex-basis`：这个参数定义了项目的基准尺寸，即多行布局中项目占用的最小空间。值可以是一个长度（如`100px`、`50%`等）或者`auto`（表示使用项目的原始尺寸）。

这三个参数都可以设置相同的值，也可以设置不同的值。例如，可以设置`flex-grow`为`2`，`flex-shrink`为`2`，`flex-basis`为`50%`，这样项目将平均地分配空间，当容器需要减少空间时，项目将按比例缩小。

## 3 React中hooks为啥不能在判断语句和循环体中使用、
 一答案：
  - 在React中，hooks只能在函数组件中使用，不能在条件语句或循环体中使用。这是因为hooks的执行顺序是在组件的渲染过程中确定的，而条件语句和循环体是在组件的渲染过程中多次执行的。如果hooks在条件语句或循环体中使用，可能会导致hooks的执行顺序不一致，导致状态和副作用的行为不一致。

  - 因此，React官方建议在hooks中使用纯函数，以避免在条件语句或循环体中使用hooks。如果需要在条件语句或循环体中使用hooks，可以将hooks的逻辑封装到一个自定义的函数中，并在条件语句或循环体中调用该函数。这样可以确保hooks的执行顺序一致，避免出现不一致的行为。
 二答案：（主要论点 ---  破坏了hooks的执行顺序）
   1. 破坏封装性和可预测性，使代码难以维护和理解
   2. 在if/循环/嵌套函数中调用hooks可能会导致调用顺序和次数的不一致引起奇怪的问题
   3. 在条件或循环中的hooks依赖项可能不会随着条件的变化而变化，导致组件无法正确重新渲染
  


## 4 useEffect和useLayoutEffect的区别
  1. `useEffect` 和 `useLayoutEffect` 都是 React 中的 Hooks，用于在函数组件中执行副作用操作。
  2. `useEffect` 的副作用操作是异步执行的（微任务），而 `useLayoutEffect` 的副作用操作是同步执行的（宏任务）。
  3. `useEffect` 的副作用操作会在组件渲染到屏幕之后执行，而 `useLayoutEffect` 的副作用操作会在浏览器布局和绘制之前执行。即`useEffect`不会阻塞渲染，而`useLayoutEffect`会阻塞渲染。
  4. `useEffect` 的副作用操作可以返回一个函数，用于清除副作用。而 `useLayoutEffect` 的副作用操作不能返回一个函数，因为它的副作用操作是同步执行的。
  5. `useEffect` 的副作用操作可以接收两个参数，分别是当前的依赖项数组和上一次的依赖项数组。而 `useLayoutEffect` 的副作用操作只能接收一个参数，即当前的依赖项数组。
## 5 垂直居中有几种方法
有多种方法可以实现css元素垂直居中：

1. 固定高度：为元素设置一个固定高度，然后在包含该元素的容器中使用 `line-height` 属性使元素垂直居中。例如：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vertical Centering</title>
</head>
<body>
    <div class="container">
        <div class="centered-element" style="height: 100px;">
            I am vertically centered!
        </div>
    </div>
</body>
</html>
```

2. flexbox布局： 在包含元素的容器中使用 `display: flex; align-items: center;`。例如：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vertical Centering</title>
    <style>
        .container {
            display: flex;
            align-items: center;
        }
        .centered-element {
            height: 100px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="centered-element">
            I am vertically centered!
        </div>
    </div>
</body>
</html>
```

3. 绝对定位： 在包含元素的容器中使用 `position: relative;`，然后使用 `top` 和 `height` 属性将元素垂直居中。例如：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vertical Centering</title>
    <style>
        .container {
            position: relative;
        }
        .centered-element {
            position: absolute;
            top: 50%;
            height: 100px;
            margin-top: -50px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="centered-element">
            I am vertically centered!
        </div>
    </div>
</body>
</html>
```

4. 表格布局： 在包含元素的容器中使用 `display: table; align-items: center;`。例如：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vertical Centering</title>
    <style>
        .container {
            display: table;
            align-items: center;
        }
        .centered-element {
            height: 100px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="centered-element">
            I am vertically centered!
        </div>
    </div>
</body>
</html>
```

根据具体需求和布局要求选择合适的方法。





## 6 vue2中自定义组件中v-madol本质是什么
## 7 重排(回流 reflow)和重绘(repaint)
## 8 自定义loader和plugin 
## 9 qiankun的css隔离
## 10 一个div 设置相对定位 再设置top 10px  与 将这个div设置transform  translateY（-10px ）有什么区别
 
在CSS中，`position: relative;` 与 `transform: translateY(-10px);` 都可以使元素相对于其正常位置进行偏移，但它们之间存在一些关键的区别：

### 使用 `position: relative;` 和 `top: 10px;`

1. **定位方式**：`position: relative;` 会将元素的定位基准点移动到其默认位置的上方10像素处，但元素仍然占据其在文档流中的原始空间。

2. **文档流影响**：元素的移动不会影响其他元素的布局。即使该元素向下移动，它在文档流中原本的位置仍然保留，可能导致其他元素的布局不发生变化。

3. **层叠上下文**：使用 `position: relative;` 不会影响元素的层叠上下文，元素保持在原有的层叠层面。

4. **百分比高度**：如果元素的高度是基于百分比计算的，即使使用 `top` 属性进行偏移，高度的计算基准仍然是元素的原始位置。

### 使用 `transform: translateY(-10px);`

1. **定位方式**：`transform: translateY(-10px);` 通过变换属性将元素视觉上向上移动10像素，但元素在文档流中的原始位置保持不变。

2. **文档流影响**：元素的移动不会影响其他元素的布局，因为 `transform` 不会影响元素在文档流中的占用空间。

3. **层叠上下文**：使用 `transform` 可能会影响元素的层叠上下文，尤其是当涉及到 `z-index` 属性时。

4. **百分比高度**：与 `position: relative;` 不同，如果元素的 `transform` 属性被应用，基于百分比计算的高度可能会根据视觉位置而非原始位置来计算（具体情况可能因浏览器而异）。

### 性能差异

- 使用 `transform` 通常被认为在性能上更优，因为浏览器可以利用硬件加速来实现更流畅的动画和变换效果，而且 `transform` 不会引起页面的重排（reflow）或重绘（repaint），而 `position` 属性的改变可能会引起重排。

### 兼容性

- 两者在现代浏览器中都得到了很好的支持，但在一些非常旧的浏览器中，`transform` 属性可能不被支持。

### 使用场景

- 当需要触发一个元素的视觉移动而不影响布局时，推荐使用 `transform`。
- 当需要改变元素的位置并且需要这个新位置参与到文档流中的布局计算时，使用 `position`。

总的来说，`position: relative;` 与 `top` 更多用于改变元素的布局位置，而 `transform: translateY(-10px);` 更多用于视觉效果上的移动，不改变文档流。根据具体的应用场景和需求，可以选择合适的方法来实现所需的布局或动画效果。




## 11 eventloop详细解释
## 12 一个页面从输入url地址到展示出来经历了写什么 细说包括（缓存，tcp怎么链接，渲染怎么渲染的）
## 13 常见的请求头响应头
在HTTP（HyperText Transfer Protocol）请求中，请求头（Request Header）用于携带请求的相关信息，而options并不是一个常见的请求头。常用的请求头包括：

1. Accept：表示客户端希望接收的文件的类型和版本。
2. Accept-Charset：表示客户端能够接受的字符集。
3. Accept-Encoding：表示客户端希望接收的文件编码方式，如gzip、deflate等。
4. Accept-Language：表示客户端希望接收的语言。
5. Connection：表示客户端与服务器的连接方式，如keep-alive表示keep-alive连接。
6. Host：表示请求的服务器名称。
7. User-Agent：表示请求客户端的浏览器、操作系统等信息。
8. Referer：表示请求的来源URL。
9. Cookie：表示客户端存储在浏览器中的cookie信息。
10. Origin：表示请求的来源域。

这些请求头在HTTP请求中是可选的，可以根据需要来设置和传递。
响应头（Response Header）是服务器在接收到HTTP请求后返回给客户端的相关信息，用于描述服务器响应的状态和内容。常见的响应头包括：

1. Content-Type：表示返回的文件类型和版本。
2. Content-Length：表示返回的文件内容长度。
3. Content-Encoding：表示返回的文件编码方式，如gzip、deflate等。
4. Content-Language：表示返回的文件语言。
5. Content-Disposition：表示返回的文件如何处理，如下载、保存等。
6. Set-Cookie：表示服务器设置的cookie信息。
7. Location：表示重定向的目标URL。
8. Server：表示服务器的类型和版本。
9. Date：表示服务器发送响应的日期和时间。
10. Last-Modified：表示资源的最后修改时间。
  

## 14 请求头里面的options是什么
在HTTP请求中，`OPTIONS`是一个常见的请求方法，用于获取服务器针对特定URL的HTTP方法支持情况。`OPTIONS`方法允许客户端发送一个HTTP请求并查看服务器的响应，以确定服务器是否支持特定的HTTP方法。   
