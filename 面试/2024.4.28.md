## 1.vue2 和vue3生命周期对比
 Vue 2 和 Vue 3 的生命周期钩子在概念上是相似的，都用于在组件的不同阶段执行特定的代码。不过，Vue 3 引入了 Composition API，这改变了一些生命周期钩子的使用方式。以下是 Vue 2 和 Vue 3 生命周期钩子的对比：

### Vue 2 生命周期钩子：

1. **beforeCreate**: 实例被创建之后被调用，在数据观测和事件/侦听器被设置之前。
2. **created**: 实例被创建后，数据已经可以被访问，但是挂载还未开始，$el 还不可用。
3. **beforeMount**: 挂载开始之前被调用，此时模板已经准备就绪，但是还没有开始渲染。
4. **mounted**: 模板已被渲染到页面上，此时可以访问和操作 DOM。
5. **beforeUpdate**: 数据更新之前调用，发生在虚拟 DOM 重新渲染和打补丁之前。
6. **updated**: 由于数据更改导致的虚拟 DOM 重新渲染和打补丁之后调用。
7. **beforeDestroy**: 实例销毁之前调用，实例仍然可用。
8. **destroyed**: 实例销毁后调用，所有东西都会解绑，所有的事件监听器都会被移除。

### Vue 3 生命周期钩子：

1. **setup()**: 在 Vue 3 的 Composition API 中，`setup()` 是一个新的组合式函数，它在组件实例初始化的早期阶段被调用，早于 `beforeCreate` 和 `created`。
2. **onBeforeMount**: 类似于 Vue 2 的 `beforeMount`，但在 `setup()` 之后调用。
3. **onMounted**: 类似于 Vue 2 的 `mounted`，模板被渲染并挂载到页面上后调用。
4. **onBeforeUpdate**: 类似于 Vue 2 的 `beforeUpdate`，数据更新前调用。
5. **onUpdated**: 类似于 Vue 2 的 `updated`，数据更新后调用。
6. **onBeforeUnmount**: 类似于 Vue 2 的 `beforeDestroy`，组件卸载前调用。
7. **onUnmounted**: 类似于 Vue 2 的 `destroyed`，组件卸载后调用。
8. **onActivated** 和 **onDeactivated**: 仅在组件被包含在 `<KeepAlive>` 缓存中时使用。
9. **onErrorCaptured**: 当捕获一个来自子孙组件的异常时激活钩子函数。

### 对比总结：

- Vue 3 引入了 Composition API，提供了 `setup()` 函数，它是 Composition API 的入口点，并且它的执行时机比 Vue 2 的 `beforeCreate` 和 `created` 更早。
- Vue 3 的生命周期钩子（如 `onMounted`, `onUpdated` 等）提供了更明确的命名，并且可以通过 Composition API 和 Options API 两种方式使用。
- Vue 2 的生命周期钩子主要是通过选项式 API 使用，而 Vue 3 鼓励使用 Composition API，尽管它仍然支持 Options API。

Vue 3 的生命周期钩子提供了更好的逻辑组合与复用，并且可以与现有的 Options API 一起使用，增加了灵活性。同时，Vue 3 也基于 TypeScript 编写，可以享受到更好的类型检查和编辑器支持。

在实际开发中，开发者可以根据项目需求和团队熟悉度选择使用 Vue 2 或 Vue 3，同时注意 Vue 3 的新特性和改进以做出适当的技术选型。


## 2. vue组件传值
在Vue.js中，组件之间的传值是构建大型应用时常见的需求。Vue提供了几种不同的方法来实现父子组件之间的数据传递，以及兄弟组件之间或跨层级组件的通信。以下是一些常用的组件传值方法：

### 1. 父子组件传值

#### a. 父向子传值 (通过`props`)：
父组件可以通过`props`将数据传递给子组件。这是Vue中推荐的组件通信方式。

**父组件：**
```vue
<template>
  <ChildComponent :parentData="someData" />
</template>

<script>
import ChildComponent from './ChildComponent.vue';

export default {
  components: {
    ChildComponent
  },
  data() {
    return {
      someData: 'Hello from parent'
    }
  }
}
</script>
```

**子组件：**
```vue
<template>
  <div>{{ parentData }}</div>
</template>

<script>
export default {
  props: ['parentData']
}
</script>
```

#### b. 子向父传值 (通过`$emit`)：
子组件可以使用`$emit`向父组件发送事件，父组件可以监听这些事件并作出响应。

**子组件：**
```vue
<template>
  <button @click="handleClick">Click me</button>
</template>

<script>
export default {
  methods: {
    handleClick() {
      this.$emit('child-to-parent', 'Data from child');
    }
  }
}
</script>
```

**父组件：**
```vue
<template>
  <ChildComponent @child-to-parent="parentMethod" />
</template>

<script>
import ChildComponent from './ChildComponent.vue';

export default {
  components: {
    ChildComponent
  },
  methods: {
    parentMethod(data) {
      console.log(data); // 输出: Data from child
    }
  }
}
</script>
```

### 2. 兄弟组件传值

对于兄弟组件之间的通信，通常会用到一个中央枢纽，如Vuex或事件总线（Event Bus），但Vue 2.4+ 也提供了`provide`和`inject`方法作为轻量级的方式。

#### a. `provide`和`inject`：
`provide` 方法可以在祖先组件中定义一个依赖，并通过 `inject` 方法在后代组件中使用它。

**祖先组件：**
```vue
<template>
  <div>
    <ChildA />
    <ChildB />
  </div>
</template>

<script>
export default {
  provide() {
    return {
      sharedData: this.sharedData
    }
  },
  data() {
    return {
      sharedData: 'Shared data'
    }
  }
}
</script>
```

**后代组件 (ChildA 或 ChildB)：**
```vue
<template>
  <div>{{ sharedData }}</div>
</template>

<script>
export default {
  inject: ['sharedData']
}
</script>
```

### 3. 跨层级组件传值

#### a. 事件总线 (Event Bus)：
使用事件总线可以在不相关的组件之间进行通信。

```javascript
// event-bus.js
import Vue from 'vue';
export const EventBus = new Vue();
```

**发射事件的组件：**
```vue
<template>
  <button @click="emitEvent"> Emit Event </button>
</template>

<script>
import { EventBus } from './event-bus.js';

export default {
  methods: {
    emitEvent() {
      EventBus.$emit('custom-event', 'Hello from event bus');
    }
  }
}
</script>
```

**监听事件的组件：**
```vue
<template>
  <div v-if="message"> {{ message }} </div>
</template>

<script>
import { EventBus } from './event-bus.js';

export default {
  data() {
    return {
      message: ''
    }
  },
  created() {
    EventBus.$on('custom-event', this.listenEvent);
  },
  beforeDestroy() {
    EventBus.$off('custom-event', this.listenEvent);
  },
  methods: {
    listenEvent(message) {
      this.message = message;
    }
  }
}
</script>
```

#### b. Vuex：
Vuex是一个专为Vue.js应用程序开发的状态管理模式和库。它采用集中式存储管理应用的所有组件的状态，并以相应的方式解决组件之间的通信问题。

### 4. 插槽 (Slots)
插槽是Vue的一个内置功能，允许你分发内容到组件的模板中。

**父组件：**
```vue
<template>
  <ChildComponent>
    <div>Slot content from parent</div>
  </ChildComponent>
</template>

<script>
import ChildComponent from './ChildComponent.vue';
</script>
```

**子组件：**
```vue
<template>
  <div>
    <slot></slot> <!-- 这将会插入父组件中的 <div> 标签 -->
  </div>
</template>
```

以上是Vue组件传值的一些常见方法。每种方法都有其使用场景，开发者可以根据具体需求选择最合适的传值方式。


## 3vue路由守卫
在Vue.js中，路由守卫（Route Guards）是一种非常有用的机制，用于在路由变化之前或之后执行代码，从而对导航进行控制。Vue Router 提供了几种不同的路由守卫，它们可以被用在全局或单个路由上。

### 全局路由守卫

全局路由守卫可以在 Vue Router 的 `beforeEach`、`beforeResolve` 和 `afterEach` 注册：

1. **beforeEach**：在路由被守卫深层遍历到达，并且该路由的组件实例被创建的每个守卫中调用。
2. **beforeResolve**：在所有组件的 `beforeRouteEnter` 和 `beforeRouteUpdate` 守卫处理完后调用。
3. **afterEach**：在跳转完成后调用。

**示例**：
```javascript
const router = new VueRouter({
  // ...定义路由
});

router.beforeEach((to, from, next) => {
  // to: 即将要进入的目标路由对象
  // from: 当前导航正要离开的路由
  // next: 一个函数，必须被调用，用来解决这个钩子。
  if (to.path === '/login' && !isAuthenticated) {
    // 如果用户未认证，则重定向到登录页面
    next('/login');
  } else {
    next();
  }
});
```

### 路由独享守卫

路由独享守卫是针对单个路由的守卫，它们可以定义在路由配置的 `beforeEnter` 属性中。

**示例**：
```javascript
const routes = [
  {
    path: '/protected',
    component: ProtectedComponent,
    beforeEnter: (to, from, next) => {
      // 确保用户已登录
      if (isAuthenticated) {
        next();
      } else {
        next('/login');
      }
    }
  }
];
```

### 组件内部守卫

组件内部守卫可以在路由组件内部使用，它们分别对应于 `beforeRouteEnter` 和 `beforeRouteUpdate` 守卫。

1. **beforeRouteEnter**：在渲染该组件的对应路由被确认前调用，不能获取 `this`，因为当守卫执行前，组件实例还没被创建。

2. **beforeRouteUpdate**：当路由改变，但是该组件被复用时（即参数发生变化，路由路径变化但该组件被再次渲染），这个守卫被调用。可以获取 `this`。

**示例**：
```javascript
export default {
  data() {
    return {
      // 组件数据
    };
  },
  beforeRouteEnter(to, from, next) {
    // 在渲染该组件的对应路由被确认前调用
    next(vm => {
      // 通过 `vm` 访问组件实例
    });
  },
  beforeRouteUpdate(to, from, next) {
    // 当路由改变且该组件被复用时，会调用这个钩子
    next();
  }
};
```

### 导航守卫的 `next` 函数

`next` 函数是路由守卫的核心，它控制着导航的流程：

- `next()`：进行正常的导航。
- `next(false)`：中止当前导航。
- `next('/')` 或 `next({ path: '/' })`：跳转到一个不同的路由。
- `next(error)`：如果 `next` 接收一个错误作为参数，导航将中止，并抛出错误。

路由守卫是Vue Router中控制页面访问权限、实现页面逻辑处理的重要机制，合理使用路由守卫可以提高应用的可维护性和用户体验。

## 4.type 和interface的区别
在编程语言中，特别是那些支持面向对象编程（OOP）的语言，`type` 和 `interface` 这两个术语通常用于定义程序中的数据结构和契约。它们各自有不同的用途和特点，但在某些语言中，它们可以互换使用。以下是一些通用的区别，以及在 TypeScript 语言中的具体应用。

### 通用区别：

1. **Type**：通常指的是一种数据类型，它可以是基本数据类型（如整数、浮点数、布尔值等），也可以是复杂类型（如类、数组、函数等）。在定义上，`type` 关注的是值的结构和形态。

2. **Interface**：则是一种强大的方式，用于定义对象的结构，即对象必须实现的属性和方法。它是一种契约，用于确保一个类或者对象实现了某些特定的接口。在定义上，`interface` 关注的是对象的行为和交互方式。

### TypeScript 中的区别：

在 TypeScript 中，`type` 和 `interface` 都可以用来定义对象的形状，但它们有以下具体的区别：

1. **声明合并**：
   - `interface` 可以被合并。如果你有两个同名的接口，TypeScript 会把它们的成员合并到一起。
   - `type` 没有合并行为，如果你声明了两个同名的类型，TypeScript 会报错。

2. **扩展**：
   - 使用 `interface` 可以很容易地通过 `extends` 关键字来扩展多个接口。
   - `type` 可以使用 `&` 操作符来合并多个类型，但这种方式不如 `interface` 的 `extends` 直观和灵活。

3. **别名**：
   - `type` 可以用于基本类型或复杂类型的别名声明，例如，你可以为复杂的联合类型或交叉类型创建一个更易读的名称。
   - `interface` 通常用于定义对象的结构，但也可以用作类型别名，尽管这通常不是推荐的做法。

4. **构造签名**：
   - `interface` 可以描述函数或构造函数的签名，并且可以包含方法。
   - `type` 也可以描述函数或构造函数的签名，并且可以为函数类型或构造签名提供别名。

5. **索引签名**：
   - 两者都可以有索引签名，但 `interface` 可以更明确地表示一个对象的结构，包括它的索引签名。

6. **类实现**：
   - 类可以实现 `interface`，这是 TypeScript 中实现接口契约的常见方式。
   - 类不能实现 `type`，因为 `type` 是类型，不是接口。

7. **声明方式**：
   - 使用 `interface` 声明时，可以定义函数的返回值类型，但函数本体不会实现。
   - 使用 `type` 声明时，如果声明了函数类型，实际上就是定义了一个函数的返回值类型。

### 示例：

```typescript
// 使用 interface 定义对象结构
interface Person {
  name: string;
  age: number;
}

// 使用 type 定义对象结构
type PersonType = {
  name: string;
  age: number;
};

// 使用 interface 定义函数签名
interface Greetable {
  greet(): void;
}

// 使用 type 定义函数签名
type GreetFunction = () => void;

// 类实现接口
class User implements Person {
  name: string;
  age: number;
  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }
}

// 类不能实现 type，因为 type 不是接口
```

在 TypeScript 中，选择使用 `type` 还是 `interface` 取决于具体的用例和个人偏好。通常，如果你需要定义一个可以被多个类实现的结构，那么 `interface` 是更好的选择。如果你只是需要为复杂的类型定义一个别名，那么 `type` 可能更合适。
