# 一、你了解过这个 ES module 吗 ，你了解 esm,amd,cmd,umd,cjs(common.js)

es module 是静态的而 common 是动态的
，Esm 是编译时确定依赖关系，其他几个都是运行时确定依赖关系，require 支持动态导入。Esm 输出的是值的引用，而 common 输出的是拷贝，所以后者一旦输出，再去修改模块内的内容是不会影响到已输出的内容的，前者的话模块内值变了，已输出的值也会变。并且 esm 也是不允许对已输出的值做修改的。

都是异步加载
AMD(require.js)推崇的是前置依赖，提前执行。CMD(sea.js)推崇的是就近依赖，延迟执行

UMD 代表通用模块定义（Universal Module Definition），是一种思想，兼容 commonjs、AMD、CMD
先判断是否支持 Nodejs 模块(exports 是否存在)，如果存在就使用 Nodejs 模块。不支持的话，再判断是否支持 AMD/CMD(判断 define 是否存在)，都不行就挂载在 window 全局对象上

# 二、常用的 plugin 有哪些？
htmlwebpackPlugin :打包生成html的
dllplugin  多进程打包的

# 三、前端工程化项目上 
  - 使用 Prettier 统一格式化代码，集成 ESLint、Stylelint 代码校验规范
  - 使用 husky、lint-staged、commitlint、czg、cz-git 规范提交信息
  延伸：
  ## 1. eslint和preitter有什么区别？
    - eslint 是一种静态代码分析工具，主要保证代码质量和规范,可以检查和修复各种问题；比如未使用的变量、不兼容的语法等。
    - Prettier专注于代码格式化，配置相对简单，它会自动对代码进行排版，包括缩进、换行、空格等 
    参考===>
    ai答：  ESLint和Prettier是两个在前端开发中常用的工具，它们有以下区别：

        1. 功能和目的：ESLint是一种静态代码分析工具，用于检查代码中的潜在问题、错误和编码规范。它可以配置自定义规则集，并提供代码质量保证和一致的编码风格。而Prettier是一种代码格式化工具，它可以自动格式化代码，确保代码的一致性和可读性。

        2. 范围：ESLint主要关注代码质量和规范，可以检查和修复各种问题，如未使用的变量、不兼容的语法等。Prettier专注于代码格式化，它会自动对代码进行排版，包括缩进、换行、空格等。

        3. 配置和规则：ESLint的配置比较灵活，可以通过配置规则集来定义代码检查的行为，同时也支持插件和扩展。Prettier的配置相对简单，主要包括一些基本的格式化选项，如缩进大小、换行符等。

        4. 工作方式：ESLint通过插件和规则来检查代码，可以在编码过程中实时检测并给出警告或错误提示。Prettier则是在代码编译、提交或保存时对整个文件进行格式化，它会根据配置对代码进行重写，使其符合统一的格式。

        5. 集成：ESLint可以与各种构建工具和编辑器集成，如webpack、babel、VS Code等，可以在构建过程中自动运行并提供实时检查功能。Prettier也可以与编辑器集成，并提供格式化命令或保存时自动格式化的功能。

        综上所述，ESLint主要关注代码质量和规范，可以进行更细粒度的代码检查和修复，而Prettier专注于代码格式化，可以统一代码样式，提供更一致的代码风格。通常情况下，两者可以结合使用，ESLint负责代码质量和规范检查，Prettier负责代码格式化，以获得更好的开发体验和代码质量。
  ## 2.husky的作用，
   - 不使用vscode的，或者没有安装eslint、preitter与stylelint插件的同学来说，就不能实现在保存的时候自动的去修复与和格式化代码，这样提交到git仓库的代码还是不符合要求的。因此需要引入强制的手段来保证提交到git仓库的代码时符合我们的要求的。husky是一个用来管理git hook的工具，git hook即在我们使用git提交代码的过程中会触发的钩子  主要用他的构子函数和上下配置插件做集成的
  ## 3.lint-staged
  lint-staged 可以让你在 Git 暂存（staged）区域中的文件上运行脚本，通常用于在提交前对代码进行格式化、静态检查等操作。可以在项目中使用 lint-staged 配合 husky 钩子来执行针对暂存文件的脚本
  ## 4.commitlint作用
  直接使用 git commit 的话还是有可能生成不规范提交的，所以还需要对最终的提交格式做一下校验

  ## 四、cjs 和esm的区别
     1. CommonJS:
        - 对于基本数据类型，属于复制。即会被模块缓存。同时，在另一个模块可以对该模块输出的变量重新赋值。

        - 对于复杂数据类型，属于浅拷贝。由于两个模块引用的对象指向同一个内存空间，因此对该模块的值做修改时会影响另一个模块。

        - 当使用require命令加载某个模块时，就会运行整个模块的代码。

        - 当使用require命令加载同一个模块时，不会再执行该模块，而是取到缓存之中的值。也就是说，CommonJS模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。

        - 循环加载时，属于加载时执行。即脚本代码在require的时候，就会全部执行。一旦出现某个模块被"循环加载"，就只输出已经执行的部分，还未执行的部分不会输出。
      2. ES6模块  
        - ES6模块中的值属于【动态只读引用】。

        - 对于只读来说，即不允许修改引入变量的值，import的变量是只读的，不论是基本数据类型还是复杂数据类型。当模块遇到import命令时，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。

        - 对于动态来说，原始值发生变化，import加载的值也会发生变化。不论是基本数据类型还是复杂数据类型。

        - 循环加载时，ES6模块是动态引用。只要两个模块之间存在某个引用，代码就能够执行。  

      3. ES6模块与CommonJS模块的区别

        1. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。

        2. CommonJS 模块的require()是同步加载模块，ES6 模块的import命令是异步加载，有一个独立的模块依赖的解析阶段。

        3. CommonJS是对模块的浅拷贝，ES6 Module是对模块的引入，即ES6 Module只存只读，不能改变其值，具体点就是指针指向不能变，类似const 。

        4. import的接口是read-only（只读状态），不能修改其变量值。 即不能修改其变量的指针指向，但可以改变变量内部指针指向。可以对commonJS对重新赋值（改变指针指向），但是对ES6 Module赋值会编译报错。
      4. ES6模块与CommonJS模块的共同点：

        1. CommonJS和ES6 Module都可以对引⼊的对象进⾏赋值，即对对象内部属性的值进行改变。


   # 五.如何优化webpack的打包（构建）速度     
   1. 使用高版本的webpack和node.js
   2. 多进程/多实例构建 thread-loader
   3. 压缩代码 ==>多进程并行压缩 webpack-paralle-uglify-pluginterser-webpack-plugin 开发parallel  mini-css-extract-plugin 
   4. 图片压缩 : magemin  、image-webpack-plugin
   5. 缩小打包作用域
     - exclude/include 确定loader规则范围
     - resolve.extensions
     - resolve.modules
   6. 提取页面公共资源
   - 基础包分离使用html-webpack-externals-plugin基础包通过cdn引入，不打入bundle中
   - 使用splitchunksplugin 公共脚本/基础包页面/公共文件进行分离
   7. 充分利用缓存提升二次构建速度
   - babel-loader 开启缓存
   - terser-webpack-plugin开启缓存
   - 使用cache-loader或者hard-source-webpack-plugin
   
   8. 缩小打包作用域（tree-shaking）
   - 打包过程中尽可能找出没有使用到的模块并打上标记
   - 尽可能找出没有使用到的export导出并删除
   - 尽可能找出没有使用到的import导入并删除
  

  # 六. 聊一聊Babel 原理
  - 解析将代码转换成AST8
  - 词法分析：将代码（字符串）分割成token流，即语法单元成数组
  - 语法分析：分析token流并生成AST
  - 转换：访问AST节点变换操作生成新的AST
  - 生成：以新的AST为基础生成代码
  #  七.webpack有哪些核心概念
  1. code splitting :拆分多个单独文件，通过配置解析规则，指定如何查找以及处理不同类型的模块
  2. mode:development production none
  3. entry:指定从哪个模块开始构建依赖图一个或多个入口模块
  4. output 指定输出路径文件名 输出一个或多个文件
  5. loaders 处理各种类型文件转化为有效模块 ES6+ 转译为浏览器可识别的 ES5 代码
  6. plugins：可执行更广泛任务的功能模块，优化打包结果、资源管理、环境变量注入等
  7. devServer 热更新 自动刷新页面 提高开发效率
  8. Resolve:模块引用关系解析模块路径

 # 八、说说webpack的热更新是如何做到的？原理是什么
  - 是什么？HMR 全称 Hot Module Replacement，可以理解为模块热替换，指在应用程序运行过程中，替换、添加、删除模块，而无需重新刷新整个应用

  - 原理：在应用程序运行过程中，监听源代码的变化，当发生变化时，重新编译打包，并将新的模块发送给浏览器端，浏览器端通过新的模块替换老的模块，从而实现实时更新
  - 实现：
    - 1. 启动一个本地服务，浏览器访问该服务
    - 2. 监听源代码变化，监听到对应的模块发生变化时，会生成两个文件.json（manifest文件）和.js文件（update chunk），并通过websocket通知浏览器端
    - 2. 浏览器端接收到通知后，通过http请求获取新的模块和.json文件
    - 4. 浏览器端通过新的模块替换老的模块，从而实现实时更新

 # 九、webpack的构建流程是什么
  - 初始化参数：从配置文件和shell语句中读取与配置相关的参数，得出最终的参数
  - 开始编译：用上一步得到的参数初始化Compiler对象，加载所有配置的插件，执行对象的run方法开始执行编译
  - 确定入口：根据配置中的entry找出所有的入口文件
  - 编译模块：从入口文件出发，调用所有配置的Loader对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理
  - 完成模块编译：在经过第4步使用Loader翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们的依赖关系
  - 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的Chunk，再把每个Chunk转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会
  - 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统