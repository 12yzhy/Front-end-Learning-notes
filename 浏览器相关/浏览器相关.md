## 1.垃圾回收机制和内存泄漏

    垃圾回收机制方法：标记清除法和引用计数法

## 2.EventLoop

先执行同步代码,遇到异步宏任务则将异步宏任务放入宏任务队列中,遇到异步微任务则将异步微任务放入微任务队列中,当所有同步代码执行完毕后,再将异步微任务从队列中调入主线程执行,微任务执行完毕后再将异步宏任务从队列中调入主线程执行,一直循环直至所有任务执行完毕

<details>
<summary>相关</summary>
    宏任务：(定)计时器，ajax,读取文件
    微任务：promise.then() ，nextTick
    执行顺序： 1.同步顺序
                2.process.nextTick（node当中才能执行）
              3. 微任务(异步队列)
              4.宏任务(异步队列)，
              5.setImmediate （当前（此次）事件循环结束后执行）
              //如下方在setTimeout(()=>{ console.log(4)},1000) 前执行
       例子：25687314
            setImmediate(()=>{
                    console.log(1)
            })
            console.log(2)
            setTimeout(()=>{ console.log(3)},0)
            setTimeout(()=>{ console.log(4)},1000)
            console.log(5)
            new Promise((resolve)=>{
                  console.log(6)
                    resolve()
            }).then(()=>{
            console.log(7)
            })
          process.nextTick(()=>{
            console.log(8)
          }) 
         //执行顺序 2,5,6,8,7,3,1,4
         因为上面的代码会先输出微任务，再输出宏任务，

这是因为宏任务被放到下个事件循环，而微任务是这次事件循环就执行的微任务，他们之间隔了一个 dom 渲染，所以造成了微任务比宏任务更快执行的错觉

</details>

​

## 3.浏览器的缓存机制

    强制缓存：
    Expires  (http1.0)

    Expire已经被Cache-Control替代，原因在于Expires控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，那么如果客户端与服务端的时间因为某些原因（例如时区不同；客户端和服务端有一方的时间不准确）发生误差，那么强制缓存则会直接失效，这样的话强制缓存的存在则毫无意义，

      Cache-Control (http1.1)  主要取值为 max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效

    协商缓存：

Etag / If-None-Match 的优先级比 Last-Modified / If-Modified-Since 高
更新资源就返回 200，不更新返回 304
Etag 、last-Modified 是服务器返回的， 在 responses header 中
If-None-Match 、If-Modified-Since 是客户端传出的，在请求头中

## 4.defer 和 async 的区别

1.默认引用 script:<script type="text/javascript" src="x.min.js"></script>

当浏览器遇到 script 标签时，文档的解析将停止，并立即下载并执行脚本，脚本执行完毕后将继续解析文档。

2.async 模式 <script type="text/javascript" src="x.min.js" async="async"></script>

当浏览器遇到 script 标签时，文档的解析不会停止，其他线程将下载脚本，脚本下载完成后开始执行脚本，脚本执行的过程中文档将停止解析，直到脚本执行完毕。

3.defer 模式 <script type="text/javascript" src="x.min.js" defer="defer"></script>

当浏览器遇到 script 标签时，文档的解析不会停止，其他线程将下载脚本，待到文档解析完成，脚本才会执行。

一句话，defer 是“渲染完再执行”，async 是“下载完就执行”。另外，如果有多个 defer 脚本，会按照它们在页面出现的顺序加载，而多个 async 脚本是不能保证加载顺序的。
