## 1.垃圾回收机制和内存泄漏

    垃圾回收机制方法：
   1. 标记清除法
```js
  标记清除是浏览器常见的垃圾回收方式，当变量进入执行环境时，就标记这个变量“进入环境”，被标记为“进入环境”的变量是不能被回收的，因为他们正在被使用。当变量离开环境时，就会被标记为“离开环境”，被标记为“离开环境”的变量会被内存释放。
垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。
```
   2. 引用计数法
```js
另外一种垃圾回收机制就是引用计数，这个用的相对较少。引用计数就是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变为0时，说明这个变量已经没有价值，因此，在回收期下次再运行时，这个变量所占有的内存空间就会被释放出来。
可能会导致循环引用的发生，只能手动清楚（手动的将值赋为null）

``` 

## 2.EventLoop

先执行同步代码,遇到异步宏任务则将异步宏任务放入宏任务队列中,遇到异步微任务则将异步微任务放入微任务队列中,当所有同步代码执行完毕后,再将异步微任务从队列中调入主线程执行,微任务执行完毕后再将异步宏任务从队列中调入主线程执行,一直循环直至所有任务执行完毕

<details>
<summary>相关</summary>
    宏任务：(定)计时器，ajax,读取文件
    微任务：promise.then() ，nextTick
    执行顺序： 1.同步顺序
                2.process.nextTick（node当中才能执行）
              3. 微任务(异步队列)
              4.宏任务(异步队列)，
              5.setImmediate （当前（此次）事件循环结束后执行）
              //如下方在setTimeout(()=>{ console.log(4)},1000) 前执行
       例子：25687314
            setImmediate(()=>{
                    console.log(1)
            })
            console.log(2)
            setTimeout(()=>{ console.log(3)},0)
            setTimeout(()=>{ console.log(4)},1000)
            console.log(5)
            new Promise((resolve)=>{
                  console.log(6)
                    resolve()
            }).then(()=>{
            console.log(7)
            })
          process.nextTick(()=>{
            console.log(8)
          }) 
         //执行顺序 2,5,6,8,7,3,1,4
         因为上面的代码会先输出微任务，再输出宏任务，

这是因为宏任务被放到下个事件循环，而微任务是这次事件循环就执行的微任务，他们之间隔了一个 dom 渲染，所以造成了微任务比宏任务更快执行的错觉

</details>

### 2.1 什么是js异步
 JS是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个。而渲染主线程承担着诸多的工作，渲染页面、执行JS都在其中运行。
 如果使用同步的方式，就极有可能导致主线程产生阻塞，从而导致消息队列中的很多其他任务无法得到执行。这样一来，一方面会导致繁忙的主线程白白的消耗时间，另一方面导致页面无法及时更新，给用户造成卡死现象
 所以浏览器采用异步的方式来避免。具体做法是当某些任务发生时，比如计时器、网络、事件监听，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。当其他线程完成时，将事先传递的回调函数包装成任务，加入到消息到的末尾排队，等待主线程调度执行。在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行。
​

## 3.浏览器的缓存机制

    强制缓存：
    Expires  (http1.0)

    Expire已经被Cache-Control替代，
    原因在于Expires控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，那么如果客户端与服务端的时间因为某些原因（例如时区不同；客户端和服务端有一方的时间不准确）发生误差，那么强制缓存则会直接失效，这样的话强制缓存的存在则毫无意义，

      Cache-Control (http1.1)  主要取值为 max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效

    协商缓存：

Etag / If-None-Match (http1.1) 的优先级比 Last-Modified / If-Modified-Since (http1.0)高
更新资源就返回 200，不更新返回 304
Etag 、last-Modified 是服务器返回的， 在 responses header 中
If-None-Match 、If-Modified-Since 是客户端传出的，在请求头中

## 4.defer 和 async 的区别

1.默认引用 script:<script type="text/javascript" src="x.min.js"></script>

当浏览器遇到 script 标签时，@@文档的解析将停止，并立即下载并执行脚本，脚本执行完毕后将继续解析文档。

2.async 模式 <script type="text/javascript" src="x.min.js" async="async"></script>

当浏览器遇到 script 标签时，@@文档的解析不会停止，其他线程将下载脚本，(区别：)脚本下载完成后开始执行脚本，(区别：)脚本执行的过程中文档将停止解析，直到脚本执行完毕。

3.defer 模式 <script type="text/javascript" src="x.min.js" defer="defer"></script>

当浏览器遇到 script 标签时，@@文档的解析不会停止，其他线程将下载脚本，(区别：)待到文档解析完成，脚本才会执行。

一句话，defer 是“渲染完再执行”，async 是“下载完就执行”。另外，如果有多个 defer 脚本，会按照它们在页面出现的顺序加载，而多个 async 脚本是不能保证加载顺序的。

## 5 浏览器的渲染原理
1、解析html树（按照文档结构从上到下执行）css树
2、从父元素开始渲染 然后才是子元素
3、渲染的时候每个元素的css属性必须有值
（整个渲染流程分为多个阶段，分别是：HTML解析、样式计算、布局、分层、绘制、分块、光栅化、画）
  a.样式声明（样式表>自定义、浏览器默认）
  b.计算层叠（权重问题） 
    比较重要性（自己>浏览器默认）
    比较特殊性（计算选择器权重值）
    比较源次序（权重值一致，后来者居上）
  c.如果可以从父元素那继承，则继承
  d.赋予默认值
  ### 5.1 什么是reflow?
  reflow的本质就是重新计算 layout 树。当进行了会影响布局树的操作后，需要重新计算布局树，会引发layout。为了避免连续的多次操作导致布局树反复计算，浏览器会合并这些操作，当JS代码全部完成后再进行统一计算。所以，改动属性造成的reflow是异步完成的。也同样因为如此，当JS获取布局属性时，就可能造成无法获取到最新的布局信息。浏览器在反复权衡下，最终决定获取属性立即reflow。
  ### 5.2 什么是repaint?
repaint的本质就是重新根据分层信息计算了绘制指令。当改动了可见样式后，就需要重新计算，会引l发repaint。由于元素的布局信息也属于可见样式，所以reflow一定会引起repaint。





  ## 6 浏览器跨页面通讯
  <!-- md无序列表 
   -->
  - BroadCast Channel
  - Service Worker
  - Localstorage window.onstorage监听
  - Shared Worker定时器轮询 （setInterval）
  - IndexedDB定时器轮询（setInterval）
  - cookie 定时器轮询(setInterval) 
  - window.open、window.postMessage
  - Websocket
  ## 7前端关键性能监控（性能指标）
  FCP(First Contentful Paint) :
     是浏览器在渲染出页面上的第一个内容（如文本、图像、SVG、Canvas 等）所花费的时间。这可以帮助衡量页面内容何时开始在用户视图中显示
  FP
     首次绘制(First Paint) ：是浏览器渲染页面上的第一个像素点所花费的时间。这可以帮助衡量页面内容何时开始在用户视图中显示
  FMP
     首次有效绘制(First Meaningful Paint) ：是页面首次有效绘制所花费的时间。这可以帮助衡量页面内容何时开始对用户产生影响
     通常是用户可交互内容的首次出现。
  LCP(Largest Contentful Paint) ：
     是页面中最大的元素所花费的时间。这可以帮助衡量页面内容何时对用户产生影响
  TTI(Time to Interactive) ：
     TTI 是指页面已完全加载，并且用户可以与页面进行交互的时间。在这个时刻，所有主要的渲染任务已完成，页面已响应用户输入。
  DOM ready(DCL)
     DOMContentLoaded 时间：DOMContentLoaded 事件在文档的 DOM（文档对象模型）已完全构建并解析完成时触发。这表示所有静态资源已下载完毕，并且 DOM 树已准备好进行渲染。
  
  - 页面大小（Page Size）：页面大小是指页面加载所需的总字节数。较大的页面大小可能会导致加载时间延长，尤其是在低带宽或高延迟网络环境下。
 
  
